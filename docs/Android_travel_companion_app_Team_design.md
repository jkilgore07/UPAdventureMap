Here is our teams design for our hybrid architecture for an Android travel companion app that combines:

- Custom pixel-art 2D maps built in Tiled
- GPS and offline routing using Mapbox
- Importing routes from Google My Maps
- Per-day layers or zones with transitions and navigation
- Game-style UX with cross-platform scalability in mind

We also compared local files vs embedded database storage for this purpose and advise how to implement a flexible layer system for trips with more than 10 days. I’ll let you know what I find shortly.

**Technical Plan: Offline Travel Companion App Design**

1. **Custom Map Rendering with Tiled (TMX) Maps**

**Use a game-style map renderer for Tiled maps.** To display each day’s custom 2D pixel-art map (created in Tiled), a rendering library or engine is needed. **LibGDX** is a strong choice: it has built-in support for Tiled **TMX** maps and efficient tile rendering on Android. For example, you can load a Tiled map with:

TiledMap map = new TmxMapLoader().load("day1.tmx");

This uses LibGDX’s TmxMapLoader to parse the TMX file and create a TiledMap object. LibGDX provides an OrthogonalTiledMapRenderer for top-down maps to draw all the tile layers efficiently (it batches drawing to minimize texture switches). Once loaded, you set up an OrthographicCamera for the visible area and render the map each frame via renderer.setView(camera) and renderer.render(). This handles panning/zooming smoothly using the GPU. Each Tiled map can have multiple layers (background, roads, overlays, etc.), and LibGDX will maintain their draw order. You can even render specific layer indices separately if you want to draw custom sprites (like the car icon) between layers.

**Maintain pixel-art style:** Use nearest-neighbor filtering so the pixel art remains crisp when scaled. In LibGDX, you can set the map’s texture filters to Nearest on load (to avoid blurry edges). Also choose an appropriate unitScale when creating the map renderer. For example, if your tiles are 32×32 pixels and you want 1 tile = 1.0 world unit, use new OrthogonalTiledMapRenderer(map, 1/32f). This way, the game world units correspond to tile units and your camera can move in tile coordinates easily. Keep the pixel-art resolution consistent across assets to preserve the retro aesthetic.

**Memory and performance:** Load one day’s map at a time to keep memory usage manageable. Each day’s map can be stored as a separate TMX file (and associated tileset images). When the user switches to another day, dispose of the previous TiledMap to free textures. LibGDX makes this easy via map.dispose() which releases the tile textures from GPU memory when a map is no longer needed. This is important if the trip has 10+ days with large maps. Also, to optimize rendering, follow best practices: minimize the number of layers and tilesets per map (each layer or tileset swap can add draw overhead). For example, use one tileset for the whole map if possible to avoid extra texture binds. And don’t use excessive layers beyond what’s needed for visual effect. In practice, a background layer, a route/road layer, and a foreground/label layer might suffice for each day. This will keep the frame rate smooth even on mid-range devices.

**Map layer organization:** Each “day” can be treated as a separate scene or map. You can maintain a simple map index and switch the renderer to a new TiledMap when the user selects a different day. We are using LibGDX, implement each day’s map as a separate Screen or just swap out the TiledMap in the renderer. The title screen (overview map) can similarly be a separate TMX (or even just an image) that shows the whole trip. For example, you might design a simplified overview map with markers for each day’s start/end; clicking on a day could instantiate that day’s TiledMap and renderer. This approach keeps each map isolated and easy to load/unload, ensuring the app supports 10+ days without slowing down.

1. **GPS Integration and Offline Navigation Overlay**

**Real GPS tracking:** The device GPS can be accessed via Android’s location services (FusedLocationProviderClient) This works offline – GPS does not require internet, though you won’t have assisted A-GPS data without a connection (it may take a bit longer to get an initial fix). The app should continuously listen for location updates and convert the raw latitude/longitude into coordinates on your custom map. This **coordinate mapping** is crucial: since your Tiled maps are not geo-referenced by default, you’ll need to establish a correspondence between lat/long and pixel coordinates in the map.

**Map calibration:** A simple way is to tag known reference points. For each day’s map, you could record the lat/long of at least two known points (e.g. the start and end of the route, or top-left and bottom-right corners of the map image) and their pixel coordinates in the Tiled map. With these, you can derive a linear transformation – essentially scale and translate – to map GPS coordinates into the map’s coordinate system. Because the areas for a single day are relatively small, a basic equirectangular projection or affine transform should be accurate enough. In practice, you might store each reference as custom properties in the TMX (e.g. startLat, startLon for a given object placed at the route start). Then when a GPS update comes in, interpolate where that would fall on the map image. This allows you to place the user’s **animated car icon** on the map at the correct location in real time.

**Routing and turn-by-turn navigation:** For offline turn-by-turn directions, **Mapbox Navigation SDK** is a robust solution. Mapbox’s SDK can perform on-device routing if you pre-download the necessary map and navigation data for the region. In Mapbox’s terminology, you create an “offline region” that includes **offline map tiles and routing tiles** for your area. When properly configured, this allows the app to plot routes and provide navigation cues without internet. In our case, the routes for each day are pre-known (the trip itinerary), so we can download the specific regions covering those routes. Using Mapbox’s OfflineManager or TileStore, you would define a geographic bounding box or polygon along each day’s route and download both the map tiles and navigation tiles for that area. This gives the SDK the road network data needed to generate or recalculate routes offline.

Mapbox’s Navigation SDK will then let you load a precomputed route (or even request a new route offline between two points within the region) and get turn-by-turn instructions. You can feed the SDK your current GPS location, and it will match it to the route (snap to road) and provide the next maneuver instruction, distance to it, etc. You don’t necessarily need to use Mapbox’s map view – you can run the navigation **in guidance mode** and overlay the info on your own map. For example, you can retrieve the route geometry (a polyline) from Mapbox Directions API (potentially done ahead of time, stored as GeoJSON), and draw that line on your Tiled map layer for visual reference. Then, use the Mapbox Navigation core to handle off-route detection and instruction generation. The turn instructions (e.g. “Turn left on Elm Street in 200m”) can be shown in a small overlay UI or spoken via TTS. Mapbox’s offline navigation does require some setup (and possibly a paid plan for broad regions). Notably, Mapbox allows offline routing for limited areas freely (they used to provide the Faroe Islands demo); for large-scale offline use, an enterprise plan/API key may be required. Since your use-case is a specific trip, you can likely confine offline data to those routes.

**Importing routes from Google My Maps:** The user mentioned using Google My Maps to plan the trip. Google My Maps allows exporting map data as KML files. Indeed, the recommended way to get a Google route into your app is: in My Maps, create the route (as a layer), then use the **“Export to KML/KMZ”** option. This will give you a KML file containing the route polyline and any waypoints or markers. Your app (or a preprocessing script) can parse the KML. There are libraries for KML, or you can use an XML parser since KML is XML. From the KML, you can extract the sequence of coordinates that make up the route. These can be converted into your map’s coordinate system and either drawn dynamically or even imported into Tiled (for example, as an **object layer** polyline).

**Overlaying navigation on the custom map:** With LIBGDX approach, you will have a polyline of the route on each day’s map. Draw this in a distinct style (e.g. a highlighted dashed line) on top of the tile layers. In LibGDX, you could either include the route path as part of the Tiled map (e.g. as a non-interactive layer or image) or draw it at runtime using LibGDX’s ShapeRenderer or sprite primitives. Drawing at runtime is flexible: you can change the color of the upcoming route segment, etc. Place the animated **car icon** at the user’s current location on the route. This could be a small sprite or an ImageView overlaid on the GLSurfaceView.  using LibGDX entirely, the car can be a Sprite drawn after the map render step. You can update its position every frame by interpolating between GPS updates for smooth movement. A cute effect might be to have a few animation frames for the car (e.g. wheels turning) and cycle through them as it moves.

Finally, ensure the app handles loss of GPS (e.g. tunnel) gracefully – maybe pausing the icon or showing “GPS lost” – and resumes when signal returns. Since all map assets and routing data are offline, the user can rely on the app even in remote areas.

1. **Title Screen and Multi-Day Map Management**

Design a **title screen** that serves as an overview of the whole trip. This screen can have a stylized map or menu that lets the user select each day. Given the pixel-art theme, you could create a single overview image (perhaps drawn in Tiled as well, or as a hand-drawn pixel map) that shows a small map of the region with the route of each day marked. For example, if the trip spans a country, the title screen might be a pixel-art map of that country with the route drawn in segments for each day, and labeled Day 1, Day 2, etc. Each segment (or an icon on each segment) could be **clickable** – tapping it opens that day’s detailed map scene.

From an implementation perspective, this title screen could simply be another TiledMap or a static image in an ImageView with clickable overlays. using LibGDX for rendering, you can implement the title screen as another Screen with its own stage: possibly use LibGDX’s 2D UI (Scene2D) to place clickable actors on top of an overview image. Alternatively, since the title screen is more UI than “game”, you could even use a standard Android XML/Compose layout for it (with ImageView and Buttons for each day), and then launch the LibGDX map activity for the selected day. Either approach is fine – what matters is that the title screen gives a clear overview and supports 10+ days. If the trip has many days, consider a scrollable list or a horizontal carousel of days in addition to the map, for usability.

**Switching maps efficiently:** When the user selects a day, you’ll initialize that day’s map and content. Ensure that any previous day’s map is not consuming resources. As mentioned, call dispose on the previous TiledMap and remove any large bitmaps from memory. The GPS listener can continue across days (it’s the same device location), but you may need to update the coordinate transform for the new map (since each map might have a different origin/scale in terms of pixels vs lat/lon). Maintain a data structure that holds calibration info and route info for each day, accessible when needed.

If the user can switch days frequently, you might preload the next day’s map in the background while showing the current day (especially if the maps are large). LibGDX’s AssetManager can load assets asynchronously, which could be used to load the upcoming day’s TMX while the user is still on the current day. However, this is an optimization; initial versions can simply show a loading screen for a second when switching days if needed.

1. **Data Storage: Local Files vs Database for Trip Content**

**Trip content structure:** The trip’s static content includes things like the route geometry for each day, waypoints or points of interest, and possibly notes or images. Since the app must work offline and the data is largely read-only, using local files is a straightforward approach. You can store routes and waypoints and embed them in the TMX map files as object layers. For example, Tiled allows adding custom object layers with points/polylines – you could include named waypoints (hotels, attractions) in the TMX itself. These would then be available at runtime via the map’s object properties (LibGDX lets you query objects by name).

Using plain files has the advantage of easy editing and portability. If the user (or you as developer) wants to update the itinerary or import a new trip, you can just drop in a new file. No migration or complex schema – it’s human-readable. This is especially useful for importing from My Maps: you could write a small converter that takes the KML and outputs a JSON or TMX layer that your app knows how to read.

**File organization:** You can package the trip files and ship them as part of app external storage so tech-savvy users could swap them (if you want mod support). For fully offline use, ensure all files are included in the app or downloaded on first run – do not rely on any network fetch. For example:

- assets/trips/roadtrip2025/day1.tmx (map for day 1) plus day1.png tileset images, etc.
- Similarly for day2…dayN.
- Possibly one trip_manifest.json listing all days and their file names, total distance, etc., which the app can load to build the UI.

This approach is simple and works cross-platform (the same files can be used on Android or iOS builds).

**Importing new trips:** Since we are using Google My Maps, you might build a small PC tool or an in-app feature to import KML. For instance, the workflow could be: user exports KML, places it in a specific folder in the device storage, and the app can read it and create a new trip entry. This would entail parsing the KML, storing the route and points into the above file structure. Initially, you might handle this import manually (as a developer step) rather than as a polished UI feature.

for now **use local files (JSON/TMX)** for trip content. It’s easy to debug and modify.

1. **Offline Mapping and Assets**

**Maps and tiles offline:** The custom maps are entirely offline (drawn by you), so no need for internet to load map imagery. All assets (car sprite, icons, etc.) should be bundled with the app. Keep them in res/drawable or assets as needed. Pixel art images compress well (PNG).

For audio (if you have any fun sound effects or if using Text-to-Speech for navigation voice), ensure that it’s available offline. Android’s TTS can work offline if the language pack is installed on the device. You might want to instruct users to download the English TTS pack beforehand if voice navigation is a feature.

1. **Scalability and Performance Considerations**

Even though the app is relatively small-scale (one trip at a time), we should design for **smooth performance** and the ability to handle longer trips or more map layers:

- **Rendering performance:** LibGDX can easily handle large tile maps (thousands of tiles) at 60 FPS on mobile, as long as you adhere to the earlier advice (few layers, atlased tilesets). For example, you could downscale the Tiled map so that it covers the day’s route in, say, a 1024x1024 tile grid, since we are building the maps to 1024x1024 tile grid size. Also make sure to **cull** tiles outside the viewport – LibGDX’s renderer does this for you, drawing only tiles within the camera view.
- **Memory:** Each day’s map will load its tileset textures. Reusing the same tileset image across days (if the style is consistent) can save memory, since the texture could remain in GPU memory. each day uses distinct artwork, that’s fine – just unload when done. Monitor heap memory too; TMX parsing will create some objects but it’s usually light (< few MB). Android devices by 2025 can handle dozens of MB easily, but keep an eye if you embed a lot of media (like if each day had unique large images).
- **Navigation performance:** Running a navigation SDK offline uses some CPU (for route calculations and map-matching GPS). Mapbox Navigation is pretty optimized in C++ under the hood. It should comfortably run on modern devices, especially for a single route that’s at most a few hundred miles. Make sure to do heavy computations off the main UI thread (LibGDX has its own render thread; any blocking calls should go in a background thread or be done before gameplay starts).
- **Multi-trip scalability:** If in the future you support multiple trips (each with ~10 day maps), you might package them as separate downloadable content to avoid bloating a single app install. In that case you can also simply list files in an assets directory. The architecture remains similar – one set of map files per trip, loaded on demand.
- **Testing offline:** Be sure to test the app in true offline mode (no WiFi/Cellular) to ensure nothing tries to fetch data. For Mapbox, this means simulating no network and confirming that routing still works using the offline data (the Mapbox SDK provides callbacks to confirm offline packs are loaded).
- **Turn off unnecessary rendering:** When the app is backgrounded or the user is on a different screen (e.g. reading info, not watching the map), you can pause the LibGDX render loop to save battery (LibGDX’s default ApplicationListener can be paused/resumed). Also update the GPS frequency based on need – e.g. when on the map navigation screen, request high frequency location updates; when on the static overview screen, maybe use a lower frequency or no GPS.
1. **Additional Notes and Libraries**

To round out the plan, here are specific tools and libraries relevant to each component, with reasoning:

- **LibGDX (Maps):** As discussed, it provides TiledMap and OrthogonalTiledMapRenderer classes for TMX maps. It handles layer transparency, object layers, tile animations (if you use any in Tiled, like an animated water tile), etc. It also gives you SpriteBatch for drawing the car icon easily. The overhead is that you are essentially writing a game loop, but since the app is map-centric, that’s acceptable.
- **Mapbox Navigation SDK:** Use version 2.x or above for offline support (the older 0.x/1.x had different APIs). Mapbox provides examples on how to download regions for offline use. You’ll need a Mapbox access token. The SDK can also provide a camera (map viewpoint) control if you were using their map, but since you have your own, you’ll mostly use the MapboxNavigation object in headless mode. Make sure to include the Mapbox Native libraries in the gradle config and follow their setup (they often require initializer calls in Application class).
- **Libraries for KML/GeoJSON:** To import data, you can use something like [Jackson](https://github.com/FasterXML/jackson) or Kotlinx Serialization if using JSON/GeoJSON. For KML (XML), Android has XML pull parsers, or use a library like [SimpleKML](https://github.com/mgogoulos/kmlparser) or even an existing GIS library if one isn’t too heavy. Because KML is XML, a quick and dirty approach is possible: search for <coordinates> tags in the KML and parse out the lat,lng pairs.
- **UI Libraries:** The app will likely have some UI elements over the map (day selection, a compass or distance display, etc.). Using **Jetpack Compose** for these could be a modern approach and it plays fine with Canvas or custom views.Traditional UI or LibGDX’s own UI system (Scene2D) are reliable choices.
- **Testing and simulation:** Use Android’s GPS simulation features (ADB commands or Android Studio’s emulator GPX playback) to test the navigation flow along your route. Prepare a GPX of the route and simulate driving it to see that the car icon moves correctly on the custom map and that turn prompts show at the right times.

since you’re already in Kotlin land, Kotlin Multiplatform/LibGDX is a coherent strategy.

By following this plan, you will create an app that blends a fun retro game map with real navigation features. The key decisions – using local TMX maps for custom visuals, overlaying GPS and route info with Mapbox’s offline navigation, and storing data in files for simplicity – all serve the goal of **full offline functionality** while keeping the implementation manageable. Each technical choice (LibGDX for rendering, Mapbox for nav, file storage for content) has been made to maximize offline reliability and future flexibility. With this setup, expanding to longer trips or other platforms will be a matter of incrementally building on the solid foundation.

[Android project setup guide](https://www.notion.so/Android-project-setup-guide-21804ec749f780d7b2c0c9f1a0949040?pvs=21)